The following are either things to be done, or ideas to consider:

- Offer a flag to merge frame/iframe elements on HTML pages as opposed to
  crawl them as separate documents.

- Add a command-line flag that saves the constructed config back to disk 
  for easy sharing (XML-write).

- Somehow have a flag that says whether to keep URL fragments or not that 
  applied to both URL extractors and redirects.  Idea: maybe have the
  URLNormalizer used by default and have that rule in?

- Carry a flag that tells if we are running a full crawl, or an incremental one.
  Some operations may be relevant only on incremental runs.

- Add total execution time, periodic time elapsed and estimated remaining.

- Store somewhere in metadata (and maybe carry in code?) whether a 
  document is new or modified.

- When issuing a STOP, add an option to specify which crawler to stop,
  and let others run.

- Add a startup flag that will generate a batch/sh script for the user which 
  abstracts the call to the config file 
  (e.g., abcCollector.sh start|stop|resume)

- Ability to crawl up to a given size.  Absolute number or percentage of 
  disk capacity? Shall we tie that to checking for remaining space? 
  We could issue warnings and/or stop when threshold is reached to 
  prevent crashing due to lack of space.

- Introduce "Add-ons" like social media add-ons to crawl social media sites.

- Consider adding engine with JavaScript runtime like Selenium (or HtmlUnit,
  or embedded browser engine) to crawl pages partly generated with JavaScript 
  (and maybe help with screenshots)?

- Have an interface for how to optionally store downloaded files
  (i.e., location, directory structure, file naming).  This could allow
  usage of the collector to clone a site.  Should the DocumentFetcher do it 
  instead?

- Have a crawler event listener that generated a tree-like graph of all URLs
  (i.e. a kind of sitemap).
  
- To consider: Interface for how to save documents whey they are kept.
  Same with default committer queue location.
  File system is used for both now, but could be others like MongoDB?
  Same as previous item?   

- Add a command prompt action to flush the committer queue. This can be useful
  if the collector crashed for some reason, while there were files left in
  the committer queue.  Shall this be done on an AbstractCommitter class
  so all future collectors automatically has that?

- Add support for having different HTTPContext for each call and/or each
  sites.
  
- Provide some duplicate content detection mechanism.  Maybe using existing 
  checksums.

- Add the ability to control how many successive crawls it has to go through
  before deleting a document because it was not found (404).

- Have configurable the level of verbosity desired when logging exceptions.
  The options could be:
     - type: none|all|first|last
     - stacktrace: false|true

- Rotate/break log files when too big.

- If a URL filter rule was changed and a document is now rejected (never 
  processed), it will not be deleted (since it did not get a 404/NOT_FOUND).
  Maybe check if rejected URL in URLProcessor are in cache and send deletion 
  if so.

- Integrate with distributed computing frameworks such as Hadoop.

- Test that IPV6 is supported (as domain names).

- Detect and follow RSS feeds (related to having multiple url extractors by
  content types).  Check related ticket(s) for a real use case.

- Offer option to have crawling rate adjust itself if a site is slow
  (in case it is the crawler hammering it).  Probably a change or new delay
  implementation... this means total download time (both for HEAD and GET) 
  should be added as document properties (not a bad idea to do regardless).

- Add option to skip certain http response code (like 500).  Those docs 
  that should not be added nor deleted because they are in a temporary bad 
  state.  Is it really useful?

- Add a GUI application to help manage collectors and report useful info.

- Deal with <a rel="noreferrer" ... ??

MAYBE:
=======
- Create an XML schema/DTD?

- Start offering per-site options?  Like crawl interval and more?
  (can be achieve with defining different crawlers now).


  <!-- TODO: Add JEF Listeners -->
  <jef>
      <errorHandlers> 
         <handler class=""></handler>
      </errorHandlers>
      <jobProgressListener> 
         <listener class=""></listener>
      </jobProgressListener>
      <suiteLifeCycleListener> 
         <listener class=""></listener>
      </suiteLifeCycleListener>
  </jef>
